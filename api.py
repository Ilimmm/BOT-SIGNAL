from fastapi import FastAPI, Request
from telegram import Update, Bot, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters
from telegram.ext import ContextTypes
import os
from contextlib import asynccontextmanager

# –°–æ–∑–¥–∞–Ω–∏–µ FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
app = FastAPI()

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ Bot
TOKEN = '7545398584:AAFcd88RjWIU4UxdXNN2EEtTlpfTPRmT0v8'
bot = Bot(token=TOKEN)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è Telegram
application = Application.builder().token(TOKEN).build()

# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    photo_url = 'https://i.postimg.cc/d3m8Lcpm/mines.jpg'
    welcome_text = """Welcome to üî∏MINES HYDRAüî∏!
    
    üí£Mines is a gambling game at the 1win betting office, based on the classic ‚ÄúMinesweeper‚Äù.
    Your goal is to open safe cells without triggering traps.

    <code>Our bot is powered by OpenAI's neural network.
    It can predict the location of stars with an 85% probability.</code>"""

    keyboard = [
        [InlineKeyboardButton("üìù REGISTRATION", callback_data='register'),
         InlineKeyboardButton("üìö INSTRUCTION", callback_data='instruction')],
        [InlineKeyboardButton("‚ùóÔ∏è GET SIGNAL ‚ùóÔ∏è", callback_data='get_signal')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è (–µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
    if 'message_id' in context.chat_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.chat_data['message_id']
            )
        except Exception as e:
            print(f"Error deleting message: {e}")
        del context.chat_data['message_id']

    # –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–æ–≤–æ–≥–æ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    message = await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo_url,
        caption=welcome_text,
        parse_mode='HTML',
        reply_markup=reply_markup
    )
    context.chat_data['message_id'] = message.message_id

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    data = query.data
    user_id = update.effective_user.id

    # –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è (–µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
    if 'message_id' in context.chat_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.chat_data['message_id']
            )
        except Exception as e:
            print(f"Error deleting message: {e}")
        del context.chat_data['message_id']

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
    if data == 'register':
        registration_photo_url = 'https://i.postimg.cc/HWQ0Sbnc/registration.jpg'
        registration_text = """After registration, send your user ID to confirm.
        Then you will receive access to the signals!"""

        keyboard = [
            [InlineKeyboardButton("üîó REGISTRATION", url='https://1wimdx.life/casino/list?open=register&p=dcau')],
            [InlineKeyboardButton("üè† MAIN MENU", callback_data='main_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        message = await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=registration_photo_url,
            caption=registration_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )
        context.chat_data['message_id'] = message.message_id

    elif data == 'get_signal':
        if 'registered_users' in context.chat_data and user_id in context.chat_data['registered_users']:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="You are successfully registered! You can now access the signals.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Open HYDRA SIGNALS", web_app=WebAppInfo(url='https://hydra-signal.onrender.com'))],
                                                  [InlineKeyboardButton("üè† MAIN MENU", callback_data='main_menu')]])
            )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="Please complete registration and send your user ID or screenshot for confirmation.",
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üè† MAIN MENU", callback_data='main_menu')]])
            )

    elif data == 'instruction':
        instruction_text = """The bot is based on and trained using OpenAI's neural network cluster üñ•[ChatGPT-v4].
        
        For training, the bot played üé∞over 8000 games.
        Currently, bot users successfully make 20-30% of their üí∏capital daily!

        <code>The bot is still learning, and its accuracy is at 85%!</code>

        Follow these instructions for maximum profit:
        
        üî∏ 1. Register at the 1WIN betting office. If it doesn‚Äôt open - use a VPN (Sweden). I use VPN Super Unlimited Proxy.
        <code>Access to signals will not be available without registration!</code>

        üî∏ 2. Deposit funds into your account.

        üî∏ 3. Go to the 1win games section and select the üí£"MINES" game.

        üî∏ 4. Set the number of traps to three. This is important!

        üî∏ 5. Request a signal from the bot and place bets based on the bot‚Äôs signals.

        üî∏ 6. In case of a losing signal, we advise you to double (X2) your bet to fully cover the loss in the next signal."""

        keyboard = [[InlineKeyboardButton("üè† MAIN MENU", callback_data='main_menu')]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=instruction_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )
        context.chat_data['message_id'] = message.message_id

    elif data == 'main_menu':
        await start(update, context)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    message = update.message.text

    if message.isdigit() and len(message) >= 8:
        if 'registered_users' not in context.chat_data:
            context.chat_data['registered_users'] = []
        context.chat_data['registered_users'].append(user_id)
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Thank you! You are now registered and can access the signals.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Open HYDRA SIGNALS", web_app=WebAppInfo(url='https://hydra-signal.onrender.com'))],
                                              [InlineKeyboardButton("üè† MAIN MENU", callback_data='main_menu')]])
        )
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Please send a valid ID (at least 8 digits) or screenshot of your registration.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üè† MAIN MENU", callback_data='main_menu')]])
        )

# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ Telegram
application.add_handler(CommandHandler("start", start))
application.add_handler(CallbackQueryHandler(button))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

# –ù–æ–≤—ã–π —Å–ø–æ—Å–æ–± —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º
@asynccontextmanager
async def lifespan(app: FastAPI):
    webhook_url = "https://hydra-python.onrender.com/webhook"  # –í–∞—à URL
    await bot.set_webhook(webhook_url)
    yield
    await bot.delete_webhook()

app = FastAPI(lifespan=lifespan)

@app.post("/webhook")
async def webhook(request: Request):
    json_update = await request.json()
    update = Update.de_json(json_update, bot)
    await application.process_update(update)
    return {"status": "ok"}

if __name__ == '__main__':
    import uvicorn
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
